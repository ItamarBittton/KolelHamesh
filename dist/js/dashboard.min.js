angular.module('RDash', [
    'ui.bootstrap',
    'ui.router',
    'ngCookies',
    'ui-notification',
    'ui.mask',
    'ngMaterial',
    'angularUtils.directives.dirPagination',
    'zt.angular-loading'
]).config(function (NotificationProvider, $qProvider) {
    $qProvider.errorOnUnhandledRejections(false);
    NotificationProvider.setOptions({
        startTop: 20,
        startRight: 10,
        verticalSpacing: 20,
        horizontalSpacing: 20,
        positionX: 'left',
        positionY: 'bottom'
    });
});
'use strict';

/**
 * Route configuration for the RDash module.
 */
angular.module('RDash').config(['$stateProvider', '$urlRouterProvider',
    function ($stateProvider, $urlRouterProvider) {

        // For unmatched routes
        $urlRouterProvider.otherwise('/');

        // Application routes
        $stateProvider
            // דף הבית    
            .state('index', {
                url: '/',
                templateUrl: 'templates/settings.html',
                controller: 'settingsController'
            })
            // למחוק
            .state('tables', {
                url: '/tables',
                templateUrl: 'templates/tables.html'
            })
            // אברכים
            .state('students', {
                url: '/students',
                templateUrl: 'templates/students.html',
                controller: 'studentController'
            })
            // כוללים
            .state('colels', {
                url: '/colels',
                templateUrl: 'templates/colel.html',
                controller: 'colelController'
            })
            // רשימת המלצות
            .state('recomends', {
                url: '/recomends',
                templateUrl: 'templates/recomends.html',
                controller: 'recomendController'
            })
            // דוח נוכחות
            .state('daily', {
                url: '/daily',
                templateUrl: 'templates/daily.html',
                controller: 'dailyController'
            })
            // ציונים
            .state('scores', {
                url: '/scores',
                templateUrl: 'templates/scores.html',
                controller: 'scoresController'
            })
            .state('reports', {
                url: '/reports',
                templateUrl: 'templates/reports.html',
                controller: 'reportsController'
            });
    }
]);
(function e(t, n, r) { function s(o, u) { if (!n[o]) { if (!t[o]) { var a = typeof require == "function" && require; if (!u && a) return a(o, !0); if (i) return i(o, !0); throw new Error("Cannot find module '" + o + "'"); } var f = n[o] = { exports: {} }; t[o][0].call(f.exports, function (e) { var n = t[o][1][e]; return s(n ? n : e); }, f, f.exports, e, t, n, r); } return n[o].exports; } var i = typeof require == "function" && require; for (var o = 0; o < r.length; o++)s(r[o]); return s; })({
    1: [function (require, module, exports) {
        (function () {
            angular.module('zt.angular-loading', []);
            require('./loading.provider.js');
            require('./loading.directive.js');
        })();
    }, { "./loading.directive.js": 2, "./loading.provider.js": 3 }], 2: [function (require, module, exports) {
        (function () {
            angular.module('zt.angular-loading')
                .directive('loading', function ($http, $timeout, Loading) {
                    return {
                        priority: -1000,
                        restrict: 'A',
                        link: function ($scope, elm, attrs) {
                            var self = this;
                            self.latencyThresholdReached = false;
                            self.latencyTimeoutSet = false;
                            $scope.isLoading = function () {
                                var numRequests;
                                if (Loading.forceLoading) {
                                    return true;
                                }
                                self.setLatencyTimeout();
                                numRequests = self.calcNumRequests();
                                self.resetTimeout(numRequests);
                                return numRequests > 0;
                            };
                            self.resetTimeout = function (numRequests) {
                                if (numRequests === 0 && self.latencyThresholdReached === true) {
                                    self.latencyTimeoutSet = false;
                                    self.latencyThresholdReached = false;
                                }
                            };
                            self.setLatencyTimeout = function () {
                                if (!self.latencyTimeoutSet) {
                                    $timeout(function () {
                                        self.latencyThresholdReached = true;
                                    }, Loading.latencyThreshold);
                                    self.latencyTimeoutSet = true;
                                }
                            };
                            self.calcNumRequests = function () {
                                var numRequests = 0;
                                for (var i = $http.pendingRequests.length - 1; i >= 0; i--) {
                                    if (Loading.requestTypes.indexOf($http.pendingRequests[i].method) < 0) {
                                        continue;
                                    }
                                    if ($http.pendingRequests[i].hideLoading) {
                                        continue;
                                    }
                                    if (self.latencyThresholdReached) {
                                        numRequests += 1;
                                    }
                                }
                                return numRequests;
                            };
                            $scope.$watch($scope.isLoading, function (status) {
                                if (status) {
                                    elm[0].style.visibility = 'visible';
                                } else {
                                    elm[0].style.visibility = 'hidden';
                                }
                            });
                        }
                    };
                });
        })();
    }, {}], 3: [function (require, module, exports) {
        (function () {
            angular.module('zt.angular-loading')
                .provider('Loading', function Loading() {
                    this.requestTypes = ['GET', 'POST', 'PUT', 'PATCH', 'DELETE'];
                    this.latencyThreshold = 0;
                    this.show = function () {
                        this.forceLoading = true;
                    }.bind(this);
                    this.hide = function () {
                        this.forceLoading = false;
                    }.bind(this);
                    this.$get = ['$timeout', function ($timeout) {
                        var self = this;
                        self.showFor = function (milliseconds) {
                            self.show();
                            $timeout(function () {
                                self.hide();
                            }, milliseconds);
                        }.bind(this);
                        return self;
                    }];
                });
        })();
    }, {}]
}, {}, [1]);
/**
 * Loading Directive
 * @see http://tobiasahlin.com/spinkit/
 */

angular
    .module('RDash')
    .directive('rdLoading', rdLoading);

function rdLoading() {
    var directive = {
        restrict: 'AE',
        template: `<svg version="1.1" id="Layer_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"
     width="24px" height="30px" viewBox="0 0 24 30" style="margin-top:10px;enable-background:new 0 0 50 50;" xml:space="preserve">
                     <rect x="0" y="10" width="4" height="10" fill="#333" opacity="0.2">
                       <animate attributeName="opacity" attributeType="XML" values="0.2; 1; .2" begin="0s" dur="0.6s" repeatCount="indefinite" />
                       <animate attributeName="height" attributeType="XML" values="10; 20; 10" begin="0s" dur="0.6s" repeatCount="indefinite" />
                       <animate attributeName="y" attributeType="XML" values="10; 5; 10" begin="0s" dur="0.6s" repeatCount="indefinite" />
                     </rect>
                     <rect x="8" y="10" width="4" height="10" fill="#333"  opacity="0.2">
                       <animate attributeName="opacity" attributeType="XML" values="0.2; 1; .2" begin="0.15s" dur="0.6s" repeatCount="indefinite" />
                       <animate attributeName="height" attributeType="XML" values="10; 20; 10" begin="0.15s" dur="0.6s" repeatCount="indefinite" />
                       <animate attributeName="y" attributeType="XML" values="10; 5; 10" begin="0.15s" dur="0.6s" repeatCount="indefinite" />
                     </rect>
                     <rect x="16" y="10" width="4" height="10" fill="#333"  opacity="0.2">
                       <animate attributeName="opacity" attributeType="XML" values="0.2; 1; .2" begin="0.3s" dur="0.6s" repeatCount="indefinite" />
                       <animate attributeName="height" attributeType="XML" values="10; 20; 10" begin="0.3s" dur="0.6s" repeatCount="indefinite" />
                       <animate attributeName="y" attributeType="XML" values="10; 5; 10" begin="0.3s" dur="0.6s" repeatCount="indefinite" />
                     </rect>
                   </svg>`
    };
    return directive;
}
angular
    .module('RDash').directive("myCalendar", function () {
        return {
            scope: {
                viewDate: "=",
                show: "&",
                status: '='
            },
            template: `<div class="board">
                           <div class="square"
                                ng-style="{'border-color': day.status}"
                                ng-class="{ 'selected' : (day.gerg.getDate() == currentDate.getDate() && day.gerg.getMonth() == currentDate.getMonth()) }" 
                                id="{{day.key}}"
                                ng-repeat='day in month'
                                ng-click="chooseDay(day)">
                               <div class="date">{{day.val}}<span ng-if="day.gerg" class="gerg">{{day.gerg.getDate() + "/"}}{{day.gerg.getMonth() + 1 == 0 ? 1 : day.gerg.getMonth() + 1}}</span></div>
                           </div>
                       </div>`,
            link: function (scope, element) {

                function week(year, month_number) {

                    var firstOfMonth = new Date(year, month_number - 1, 1);
                    var lastOfMonth = new Date(year, month_number, 0);

                    var used = firstOfMonth.getDay() + lastOfMonth.getDate();

                    return Math.ceil(used / 7);
                }


                scope.$watch("status", function (newValue, oldValue) {
                    if (newValue && newValue.length && !angular.equals(newValue, oldValue)) {
                        if (!scope.viewDate) {
                            scope.viewDate = {
                                year: new Date().getFullYear(),
                                month: new Date().getMonth() + 1
                            };
                        }
                        var month = scope.viewDate.month - 1,
                            year = scope.viewDate.year,
                            range = new Date(year, scope.viewDate.month, 0).getDate(),
                            start = new Date(year, month, 1).getDay();

                        var weekAmount = week(year, month + 1);
                        scope.month = new Array(weekAmount * 7);
                        var currDay = 0;
                        for (var i = 0; i < scope.month.length; i++) {
                            if (i < start || i >= range + start) {
                                scope.month[i] = {
                                    key: i
                                };
                            } else {
                                var today = new Date(year, month, currDay + 1),
                                    HebDate = new Hebcal.HDate(new Date(today)).toString('h').split(' ').slice(0, 2).join(' ');
                                scope.month[i] = {
                                    key: i,
                                    val: HebDate,
                                    gerg: today,
                                    status: scope.status[currDay]
                                };
                                currDay++;
                            }
                        }
                    }
                });

                scope.$watch("viewDate", function (newValue, oldValue) {
                    if (newValue) {
                        var month = scope.viewDate.month - 1,
                            year = scope.viewDate.year,
                            range = new Date(year, scope.viewDate.month, 0).getDate(),
                            start = new Date(year, month, 1).getDay();

                        scope.selected = false;
                        scope.currentDate = scope.currentDate || new Date();
                        scope.chooseDay = function (day) {
                            var elementsSelected = document.querySelector(".selected");
                            if (elementsSelected) elementsSelected.classList.remove("selected");
                            document.getElementById(day.key).className += ' selected';
                            day.selected = true;
                            scope.show({
                                date: day.gerg,
                                hebDate: day
                            });
                        };

                        var weekAmount = week(year, month + 1);
                        scope.month = new Array(weekAmount * 7);
                        var currDay = 0;
                        for (var i = 0; i < scope.month.length; i++) {
                            if (i < start || i >= range + start) {
                                scope.month[i] = {
                                    key: i
                                };
                            } else {
                                var today = new Date(year, month, currDay + 1),
                                    HebDate = new Hebcal.HDate(new Date(today)).toString('h').split(' ').slice(0, 2).join(' ');
                                scope.month[i] = {
                                    key: i,
                                    val: HebDate,
                                    gerg: today,
                                    status: scope.status[currDay]
                                };
                                currDay++;
                            }
                        }
                    }
                });
            }
        };
    });
/**
 * dirPagination - AngularJS module for paginating (almost) anything.
 *
 *
 * Credits
 * =======
 *
 * Daniel Tabuenca: https://groups.google.com/d/msg/angular/an9QpzqIYiM/r8v-3W1X5vcJ
 * for the idea on how to dynamically invoke the ng-repeat directive.
 *
 * I borrowed a couple of lines and a few attribute names from the AngularUI Bootstrap project:
 * https://github.com/angular-ui/bootstrap/blob/master/src/pagination/pagination.js
 *
 * Copyright 2014 Michael Bromley <michael@michaelbromley.co.uk>
 */

(function() {

    /**
     * Config
     */
    var moduleName = 'angularUtils.directives.dirPagination';
    var DEFAULT_ID = '__default';

    /**
     * Module
     */
    angular.module(moduleName, [])
        .directive('dirPaginate', ['$compile', '$parse', 'paginationService', dirPaginateDirective])
        .directive('dirPaginateNoCompile', noCompileDirective)
        .directive('dirPaginationControls', ['paginationService', 'paginationTemplate', dirPaginationControlsDirective])
        .filter('itemsPerPage', ['paginationService', itemsPerPageFilter])
        .service('paginationService', paginationService)
        .provider('paginationTemplate', paginationTemplateProvider)
        .run(['$templateCache',dirPaginationControlsTemplateInstaller]);

    function dirPaginateDirective($compile, $parse, paginationService) {

        return  {
            terminal: true,
            multiElement: true,
            priority: 100,
            compile: dirPaginationCompileFn
        };

        function dirPaginationCompileFn(tElement, tAttrs){

            var expression = tAttrs.dirPaginate;
            // regex taken directly from https://github.com/angular/angular.js/blob/v1.4.x/src/ng/directive/ngRepeat.js#L339
            var match = expression.match(/^\s*([\s\S]+?)\s+in\s+([\s\S]+?)(?:\s+as\s+([\s\S]+?))?(?:\s+track\s+by\s+([\s\S]+?))?\s*$/);

            var filterPattern = /\|\s*itemsPerPage\s*:\s*(.*\(\s*\w*\)|([^\)]*?(?=\s+as\s+))|[^\)]*)/;
            if (match[2].match(filterPattern) === null) {
                throw 'pagination directive: the \'itemsPerPage\' filter must be set.';
            }
            var itemsPerPageFilterRemoved = match[2].replace(filterPattern, '');
            var collectionGetter = $parse(itemsPerPageFilterRemoved);

            addNoCompileAttributes(tElement);

            // If any value is specified for paginationId, we register the un-evaluated expression at this stage for the benefit of any
            // dir-pagination-controls directives that may be looking for this ID.
            var rawId = tAttrs.paginationId || DEFAULT_ID;
            paginationService.registerInstance(rawId);

            return function dirPaginationLinkFn(scope, element, attrs){

                // Now that we have access to the `scope` we can interpolate any expression given in the paginationId attribute and
                // potentially register a new ID if it evaluates to a different value than the rawId.
                var paginationId = $parse(attrs.paginationId)(scope) || attrs.paginationId || DEFAULT_ID;
                
                // (TODO: this seems sound, but I'm reverting as many bug reports followed it's introduction in 0.11.0.
                // Needs more investigation.)
                // In case rawId != paginationId we deregister using rawId for the sake of general cleanliness
                // before registering using paginationId
                // paginationService.deregisterInstance(rawId);
                paginationService.registerInstance(paginationId);

                var repeatExpression = getRepeatExpression(expression, paginationId);
                addNgRepeatToElement(element, attrs, repeatExpression);

                removeTemporaryAttributes(element);
                var compiled =  $compile(element);

                var currentPageGetter = makeCurrentPageGetterFn(scope, attrs, paginationId);
                paginationService.setCurrentPageParser(paginationId, currentPageGetter, scope);

                if (typeof attrs.totalItems !== 'undefined') {
                    paginationService.setAsyncModeTrue(paginationId);
                    scope.$watch(function() {
                        return $parse(attrs.totalItems)(scope);
                    }, function (result) {
                        if (0 <= result) {
                            paginationService.setCollectionLength(paginationId, result);
                        }
                    });
                } else {
                    paginationService.setAsyncModeFalse(paginationId);
                    scope.$watchCollection(function() {
                        return collectionGetter(scope);
                    }, function(collection) {
                        if (collection) {
                            var collectionLength = (collection instanceof Array) ? collection.length : Object.keys(collection).length;
                            paginationService.setCollectionLength(paginationId, collectionLength);
                        }
                    });
                }

                // Delegate to the link function returned by the new compilation of the ng-repeat
                compiled(scope);
                 
                // (TODO: Reverting this due to many bug reports in v 0.11.0. Needs investigation as the
                // principle is sound)
                // When the scope is destroyed, we make sure to remove the reference to it in paginationService
                // so that it can be properly garbage collected
                // scope.$on('$destroy', function destroyDirPagination() {
                //     paginationService.deregisterInstance(paginationId);
                // });
            };
        }

        /**
         * If a pagination id has been specified, we need to check that it is present as the second argument passed to
         * the itemsPerPage filter. If it is not there, we add it and return the modified expression.
         *
         * @param expression
         * @param paginationId
         * @returns {*}
         */
        function getRepeatExpression(expression, paginationId) {
            var repeatExpression,
                idDefinedInFilter = !!expression.match(/(\|\s*itemsPerPage\s*:[^|]*:[^|]*)/);

            if (paginationId !== DEFAULT_ID && !idDefinedInFilter) {
                repeatExpression = expression.replace(/(\|\s*itemsPerPage\s*:\s*[^|\s]*)/, "$1 : '" + paginationId + "'");
            } else {
                repeatExpression = expression;
            }

            return repeatExpression;
        }

        /**
         * Adds the ng-repeat directive to the element. In the case of multi-element (-start, -end) it adds the
         * appropriate multi-element ng-repeat to the first and last element in the range.
         * @param element
         * @param attrs
         * @param repeatExpression
         */
        function addNgRepeatToElement(element, attrs, repeatExpression) {
            if (element[0].hasAttribute('dir-paginate-start') || element[0].hasAttribute('data-dir-paginate-start')) {
                // using multiElement mode (dir-paginate-start, dir-paginate-end)
                attrs.$set('ngRepeatStart', repeatExpression);
                element.eq(element.length - 1).attr('ng-repeat-end', true);
            } else {
                attrs.$set('ngRepeat', repeatExpression);
            }
        }

        /**
         * Adds the dir-paginate-no-compile directive to each element in the tElement range.
         * @param tElement
         */
        function addNoCompileAttributes(tElement) {
            angular.forEach(tElement, function(el) {
                if (el.nodeType === 1) {
                    angular.element(el).attr('dir-paginate-no-compile', true);
                }
            });
        }

        /**
         * Removes the variations on dir-paginate (data-, -start, -end) and the dir-paginate-no-compile directives.
         * @param element
         */
        function removeTemporaryAttributes(element) {
            angular.forEach(element, function(el) {
                if (el.nodeType === 1) {
                    angular.element(el).removeAttr('dir-paginate-no-compile');
                }
            });
            element.eq(0).removeAttr('dir-paginate-start').removeAttr('dir-paginate').removeAttr('data-dir-paginate-start').removeAttr('data-dir-paginate');
            element.eq(element.length - 1).removeAttr('dir-paginate-end').removeAttr('data-dir-paginate-end');
        }

        /**
         * Creates a getter function for the current-page attribute, using the expression provided or a default value if
         * no current-page expression was specified.
         *
         * @param scope
         * @param attrs
         * @param paginationId
         * @returns {*}
         */
        function makeCurrentPageGetterFn(scope, attrs, paginationId) {
            var currentPageGetter;
            if (attrs.currentPage) {
                currentPageGetter = $parse(attrs.currentPage);
            } else {
                // If the current-page attribute was not set, we'll make our own.
                // Replace any non-alphanumeric characters which might confuse
                // the $parse service and give unexpected results.
                // See https://github.com/michaelbromley/angularUtils/issues/233
                var defaultCurrentPage = (paginationId + '__currentPage').replace(/\W/g, '_');
                scope[defaultCurrentPage] = 1;
                currentPageGetter = $parse(defaultCurrentPage);
            }
            return currentPageGetter;
        }
    }

    /**
     * This is a helper directive that allows correct compilation when in multi-element mode (ie dir-paginate-start, dir-paginate-end).
     * It is dynamically added to all elements in the dir-paginate compile function, and it prevents further compilation of
     * any inner directives. It is then removed in the link function, and all inner directives are then manually compiled.
     */
    function noCompileDirective() {
        return {
            priority: 5000,
            terminal: true
        };
    }

    function dirPaginationControlsTemplateInstaller($templateCache) {
        $templateCache.put('angularUtils.directives.dirPagination.template', '<ul class="pagination" ng-if="1 < pages.length || !autoHide"><li ng-if="boundaryLinks" ng-class="{ disabled : pagination.current == 1 }"><a href="" ng-click="setCurrent(1)">&laquo;</a></li><li ng-if="directionLinks" ng-class="{ disabled : pagination.current == 1 }"><a href="" ng-click="setCurrent(pagination.current - 1)">&lsaquo;</a></li><li ng-repeat="pageNumber in pages track by tracker(pageNumber, $index)" ng-class="{ active : pagination.current == pageNumber, disabled : pageNumber == \'...\' || ( ! autoHide && pages.length === 1 ) }"><a href="" ng-click="setCurrent(pageNumber)">{{ pageNumber }}</a></li><li ng-if="directionLinks" ng-class="{ disabled : pagination.current == pagination.last }"><a href="" ng-click="setCurrent(pagination.current + 1)">&rsaquo;</a></li><li ng-if="boundaryLinks"  ng-class="{ disabled : pagination.current == pagination.last }"><a href="" ng-click="setCurrent(pagination.last)">&raquo;</a></li></ul>');
    }

    function dirPaginationControlsDirective(paginationService, paginationTemplate) {

        var numberRegex = /^\d+$/;

        var DDO = {
            restrict: 'AE',
            scope: {
                maxSize: '=?',
                onPageChange: '&?',
                paginationId: '=?',
                autoHide: '=?'
            },
            link: dirPaginationControlsLinkFn
        };

        // We need to check the paginationTemplate service to see whether a template path or
        // string has been specified, and add the `template` or `templateUrl` property to
        // the DDO as appropriate. The order of priority to decide which template to use is
        // (highest priority first):
        // 1. paginationTemplate.getString()
        // 2. attrs.templateUrl
        // 3. paginationTemplate.getPath()
        var templateString = paginationTemplate.getString();
        if (templateString !== undefined) {
            DDO.template = templateString;
        } else {
            DDO.templateUrl = function(elem, attrs) {
                return attrs.templateUrl || paginationTemplate.getPath();
            };
        }
        return DDO;

        function dirPaginationControlsLinkFn(scope, element, attrs) {

            // rawId is the un-interpolated value of the pagination-id attribute. This is only important when the corresponding dir-paginate directive has
            // not yet been linked (e.g. if it is inside an ng-if block), and in that case it prevents this controls directive from assuming that there is
            // no corresponding dir-paginate directive and wrongly throwing an exception.
            var rawId = attrs.paginationId ||  DEFAULT_ID;
            var paginationId = scope.paginationId || attrs.paginationId ||  DEFAULT_ID;

            if (!paginationService.isRegistered(paginationId) && !paginationService.isRegistered(rawId)) {
                var idMessage = (paginationId !== DEFAULT_ID) ? ' (id: ' + paginationId + ') ' : ' ';
                if (window.console) {
                    console.warn('Pagination directive: the pagination controls' + idMessage + 'cannot be used without the corresponding pagination directive, which was not found at link time.');
                }
            }

            if (!scope.maxSize) { scope.maxSize = 9; }
            scope.autoHide = scope.autoHide === undefined ? true : scope.autoHide;
            scope.directionLinks = angular.isDefined(attrs.directionLinks) ? scope.$parent.$eval(attrs.directionLinks) : true;
            scope.boundaryLinks = angular.isDefined(attrs.boundaryLinks) ? scope.$parent.$eval(attrs.boundaryLinks) : false;

            var paginationRange = Math.max(scope.maxSize, 5);
            scope.pages = [];
            scope.pagination = {
                last: 1,
                current: 1
            };
            scope.range = {
                lower: 1,
                upper: 1,
                total: 1
            };

            scope.$watch('maxSize', function(val) {
                if (val) {
                    paginationRange = Math.max(scope.maxSize, 5);
                    generatePagination();
                }
            });

            scope.$watch(function() {
                if (paginationService.isRegistered(paginationId)) {
                    return (paginationService.getCollectionLength(paginationId) + 1) * paginationService.getItemsPerPage(paginationId);
                }
            }, function(length) {
                if (0 < length) {
                    generatePagination();
                }
            });

            scope.$watch(function() {
                if (paginationService.isRegistered(paginationId)) {
                    return (paginationService.getItemsPerPage(paginationId));
                }
            }, function(current, previous) {
                if (current != previous && typeof previous !== 'undefined') {
                    goToPage(scope.pagination.current);
                }
            });

            scope.$watch(function() {
                if (paginationService.isRegistered(paginationId)) {
                    return paginationService.getCurrentPage(paginationId);
                }
            }, function(currentPage, previousPage) {
                if (currentPage != previousPage) {
                    goToPage(currentPage);
                }
            });

            scope.setCurrent = function(num) {
                if (paginationService.isRegistered(paginationId) && isValidPageNumber(num)) {
                    num = parseInt(num, 10);
                    paginationService.setCurrentPage(paginationId, num);
                }
            };

            /**
             * Custom "track by" function which allows for duplicate "..." entries on long lists,
             * yet fixes the problem of wrongly-highlighted links which happens when using
             * "track by $index" - see https://github.com/michaelbromley/angularUtils/issues/153
             * @param id
             * @param index
             * @returns {string}
             */
            scope.tracker = function(id, index) {
                return id + '_' + index;
            };

            function goToPage(num) {
                if (paginationService.isRegistered(paginationId) && isValidPageNumber(num)) {
                    var oldPageNumber = scope.pagination.current;

                    scope.pages = generatePagesArray(num, paginationService.getCollectionLength(paginationId), paginationService.getItemsPerPage(paginationId), paginationRange);
                    scope.pagination.current = num;
                    updateRangeValues();

                    // if a callback has been set, then call it with the page number as the first argument
                    // and the previous page number as a second argument
                    if (scope.onPageChange) {
                        scope.onPageChange({
                            newPageNumber : num,
                            oldPageNumber : oldPageNumber
                        });
                    }
                }
            }

            function generatePagination() {
                if (paginationService.isRegistered(paginationId)) {
                    var page = parseInt(paginationService.getCurrentPage(paginationId)) || 1;
                    scope.pages = generatePagesArray(page, paginationService.getCollectionLength(paginationId), paginationService.getItemsPerPage(paginationId), paginationRange);
                    scope.pagination.current = page;
                    scope.pagination.last = scope.pages[scope.pages.length - 1];
                    if (scope.pagination.last < scope.pagination.current) {
                        scope.setCurrent(scope.pagination.last);
                    } else {
                        updateRangeValues();
                    }
                }
            }

            /**
             * This function updates the values (lower, upper, total) of the `scope.range` object, which can be used in the pagination
             * template to display the current page range, e.g. "showing 21 - 40 of 144 results";
             */
            function updateRangeValues() {
                if (paginationService.isRegistered(paginationId)) {
                    var currentPage = paginationService.getCurrentPage(paginationId),
                        itemsPerPage = paginationService.getItemsPerPage(paginationId),
                        totalItems = paginationService.getCollectionLength(paginationId);

                    scope.range.lower = (currentPage - 1) * itemsPerPage + 1;
                    scope.range.upper = Math.min(currentPage * itemsPerPage, totalItems);
                    scope.range.total = totalItems;
                }
            }
            function isValidPageNumber(num) {
                return (numberRegex.test(num) && (0 < num && num <= scope.pagination.last));
            }
        }

        /**
         * Generate an array of page numbers (or the '...' string) which is used in an ng-repeat to generate the
         * links used in pagination
         *
         * @param currentPage
         * @param rowsPerPage
         * @param paginationRange
         * @param collectionLength
         * @returns {Array}
         */
        function generatePagesArray(currentPage, collectionLength, rowsPerPage, paginationRange) {
            var pages = [];
            var totalPages = Math.ceil(collectionLength / rowsPerPage);
            var halfWay = Math.ceil(paginationRange / 2);
            var position;

            if (currentPage <= halfWay) {
                position = 'start';
            } else if (totalPages - halfWay < currentPage) {
                position = 'end';
            } else {
                position = 'middle';
            }

            var ellipsesNeeded = paginationRange < totalPages;
            var i = 1;
            while (i <= totalPages && i <= paginationRange) {
                var pageNumber = calculatePageNumber(i, currentPage, paginationRange, totalPages);

                var openingEllipsesNeeded = (i === 2 && (position === 'middle' || position === 'end'));
                var closingEllipsesNeeded = (i === paginationRange - 1 && (position === 'middle' || position === 'start'));
                if (ellipsesNeeded && (openingEllipsesNeeded || closingEllipsesNeeded)) {
                    pages.push('...');
                } else {
                    pages.push(pageNumber);
                }
                i ++;
            }
            return pages;
        }

        /**
         * Given the position in the sequence of pagination links [i], figure out what page number corresponds to that position.
         *
         * @param i
         * @param currentPage
         * @param paginationRange
         * @param totalPages
         * @returns {*}
         */
        function calculatePageNumber(i, currentPage, paginationRange, totalPages) {
            var halfWay = Math.ceil(paginationRange/2);
            if (i === paginationRange) {
                return totalPages;
            } else if (i === 1) {
                return i;
            } else if (paginationRange < totalPages) {
                if (totalPages - halfWay < currentPage) {
                    return totalPages - paginationRange + i;
                } else if (halfWay < currentPage) {
                    return currentPage - halfWay + i;
                } else {
                    return i;
                }
            } else {
                return i;
            }
        }
    }

    /**
     * This filter slices the collection into pages based on the current page number and number of items per page.
     * @param paginationService
     * @returns {Function}
     */
    function itemsPerPageFilter(paginationService) {

        return function(collection, itemsPerPage, paginationId) {
            if (typeof (paginationId) === 'undefined') {
                paginationId = DEFAULT_ID;
            }
            if (!paginationService.isRegistered(paginationId)) {
                throw 'pagination directive: the itemsPerPage id argument (id: ' + paginationId + ') does not match a registered pagination-id.';
            }
            var end;
            var start;
            if (angular.isObject(collection)) {
                itemsPerPage = parseInt(itemsPerPage) || 9999999999;
                if (paginationService.isAsyncMode(paginationId)) {
                    start = 0;
                } else {
                    start = (paginationService.getCurrentPage(paginationId) - 1) * itemsPerPage;
                }
                end = start + itemsPerPage;
                paginationService.setItemsPerPage(paginationId, itemsPerPage);

                if (collection instanceof Array) {
                    // the array just needs to be sliced
                    return collection.slice(start, end);
                } else {
                    // in the case of an object, we need to get an array of keys, slice that, then map back to
                    // the original object.
                    var slicedObject = {};
                    angular.forEach(keys(collection).slice(start, end), function(key) {
                        slicedObject[key] = collection[key];
                    });
                    return slicedObject;
                }
            } else {
                return collection;
            }
        };
    }

    /**
     * Shim for the Object.keys() method which does not exist in IE < 9
     * @param obj
     * @returns {Array}
     */
    function keys(obj) {
        if (!Object.keys) {
            var objKeys = [];
            for (var i in obj) {
                if (obj.hasOwnProperty(i)) {
                    objKeys.push(i);
                }
            }
            return objKeys;
        } else {
            return Object.keys(obj);
        }
    }

    /**
     * This service allows the various parts of the module to communicate and stay in sync.
     */
    function paginationService() {

        var instances = {};
        var lastRegisteredInstance;

        this.registerInstance = function(instanceId) {
            if (typeof instances[instanceId] === 'undefined') {
                instances[instanceId] = {
                    asyncMode: false
                };
                lastRegisteredInstance = instanceId;
            }
        };

        this.deregisterInstance = function(instanceId) {
            delete instances[instanceId];
        };
        
        this.isRegistered = function(instanceId) {
            return (typeof instances[instanceId] !== 'undefined');
        };

        this.getLastInstanceId = function() {
            return lastRegisteredInstance;
        };

        this.setCurrentPageParser = function(instanceId, val, scope) {
            instances[instanceId].currentPageParser = val;
            instances[instanceId].context = scope;
        };
        this.setCurrentPage = function(instanceId, val) {
            instances[instanceId].currentPageParser.assign(instances[instanceId].context, val);
        };
        this.getCurrentPage = function(instanceId) {
            var parser = instances[instanceId].currentPageParser;
            return parser ? parser(instances[instanceId].context) : 1;
        };

        this.setItemsPerPage = function(instanceId, val) {
            instances[instanceId].itemsPerPage = val;
        };
        this.getItemsPerPage = function(instanceId) {
            return instances[instanceId].itemsPerPage;
        };

        this.setCollectionLength = function(instanceId, val) {
            instances[instanceId].collectionLength = val;
        };
        this.getCollectionLength = function(instanceId) {
            return instances[instanceId].collectionLength;
        };

        this.setAsyncModeTrue = function(instanceId) {
            instances[instanceId].asyncMode = true;
        };

        this.setAsyncModeFalse = function(instanceId) {
            instances[instanceId].asyncMode = false;
        };

        this.isAsyncMode = function(instanceId) {
            return instances[instanceId].asyncMode;
        };
    }

    /**
     * This provider allows global configuration of the template path used by the dir-pagination-controls directive.
     */
    function paginationTemplateProvider() {

        var templatePath = 'angularUtils.directives.dirPagination.template';
        var templateString;

        /**
         * Set a templateUrl to be used by all instances of <dir-pagination-controls>
         * @param {String} path
         */
        this.setPath = function(path) {
            templatePath = path;
        };

        /**
         * Set a string of HTML to be used as a template by all instances
         * of <dir-pagination-controls>. If both a path *and* a string have been set,
         * the string takes precedence.
         * @param {String} str
         */
        this.setString = function(str) {
            templateString = str;
        };

        this.$get = function() {
            return {
                getPath: function() {
                    return templatePath;
                },
                getString: function() {
                    return templateString;
                }
            };
        };
    }
})();
angular
    .module('RDash').directive("studentList", function () {
        return {
            scope: {
                students: "=",
                dropList: "="
            },
            template: `
            <div>
                <table class="table">
                    <thead>
                        <td>שם משפחה</td>
                        <td>שם פרטי</td>
                        <td>טלפון</td>
                        <td ng-repeat="title in dropList.title">{{title}}</td>
                    </thead>
                    <tbody>
                        <tr ng-repeat="student in students" ng-style="{'background-color' : student.is_deleted && 'gray'}">
                            <td>{{student.last_name}}</td>
                            <td>{{student.first_name}}</td>
                            <td>{{student.phone}}</td>
                            <td>
                                <select 
                                        ng-model="student.presence" 
                                        ng-options="def.value as def.name for def in dropList.options" class="form-control">
                                </select>
                            </td>
                        </tr>
                    </tbody>
                </table>
		    </div>`,
            link: function (scope) {

            }
        };
    });
/**
 * Widget Body Directive
 */

angular
    .module('RDash')
    .directive('rdWidgetBody', rdWidgetBody);

function rdWidgetBody() {
    var directive = {
        requires: '^rdWidget',
        scope: {
            loading: '=?',
            classes: '@?'
        },
        transclude: true,
        template: '<div class="widget-body" ng-class="classes"><rd-loading ng-show="loading"></rd-loading><div ng-hide="loading" class="widget-content" ng-transclude></div></div>',
        restrict: 'E'
    };
    return directive;
}

/**
 * Widget Footer Directive
 */

angular
    .module('RDash')
    .directive('rdWidgetFooter', rdWidgetFooter);

function rdWidgetFooter() {
    var directive = {
        requires: '^rdWidget',
        transclude: true,
        template: '<div class="widget-footer" ng-transclude></div>',
        restrict: 'E'
    };
    return directive;
}
/**
 * Widget Header Directive
 */

angular
    .module('RDash')
    .directive('rdWidgetHeader', rdWidgetTitle);

function rdWidgetTitle() {
    var directive = {
        requires: '^rdWidget',
        scope: {
            title: '@',
            icon: '@'
        },
        transclude: true,
        template: '<div class="widget-header"><div class="row"><div class="pull-right"><i class="fa" ng-class="icon"></i> {{title}} </div><div class="pull-left" ng-transclude></div></div></div>',
        restrict: 'E'
    };
    return directive;
}
/**
 * Widget Directive
 */

angular
    .module('RDash')
    .directive('rdWidget', rdWidget);

function rdWidget() {
    var directive = {
        transclude: true,
        template: '<div class="widget" ng-transclude></div>',
        restrict: 'EA'
    };
    return directive;

    function link(scope, element, attrs) {
        /* */
    }
}
angular.module('RDash').filter('inputfilter', function () {
    return function (item) {
        if (!item) return "";
        if (!item.schedule) return item;

        item.schedule.forEach(function (a, b) {
            item[b] = a.start + ' - ' + a.end;
        });

        delete item.schedule;

        return item;
    };
});
angular.module('RDash').filter('timeFilter', function ($filter) {
    return function (input) {
        if (typeof input !== "number" || input < 0) return "00:00";

        function pad(n) { return (n < 10 ? '0' : '') + n; }

        var hours = pad(parseInt(input));
        var minutes = pad(Math.ceil(input % 1 * 60));

        return ($filter('number')(hours) + ':' + minutes);
    };
});
// This service connects to our REST API
angular.module('RDash').factory("Data", function ($http, Notification) {

    var serviceBase = '/';

    var obj = {};
    var alertMessage = function (data) {
        if (data.success) Notification.success(data.success);
        if (data.error) Notification.error(data.error);
    };
    obj.get = function (q, external) {
        var path = external ? q : serviceBase + q;
        return $http.get(path).then(function (results) {
            alertMessage(results.data);
            return results.data;
        });
    };
    obj.post = function (q, object) {
        return $http.post(serviceBase + q, object).then(function (results) {
            alertMessage(results.data);
            return results.data;
        });
    };
    obj.put = function (q, object) {
        return $http.put(serviceBase + q, object).then(function (results) {
            alertMessage(results.data);
            return results.data;
        });
    };
    obj.delete = function (q) {
        return $http.delete(serviceBase + q).then(function (results) {
            alertMessage(results.data);
            return results.data;
        });
    };

    return obj;
});
angular.module('RDash').service("Helper", function () {
    this.parseJson = function (data) {
        try {
            var a = JSON.parse(data);
            return a;
        } catch (ex) {
            return {};
        }
    };
    
    this.stringifyJson = function (data) {
        try {
            var a = JSON.stringify(data);
            return a;
        } catch (ex) {
            return "";
        }
    };
});
// This service translates keys to hebrew.
angular.module('RDash').constant("translate", {
    "account": "חשבון",
    "account_name": "על שם",
    "bank": "בנק",
    "branch": "סניף",
    "city": "עיר",
    "first_name": "שם פרטי",
    "house": "מס בית",
    "id": "זהות",
    "last_name": "שם משפחה",
    "phone": "טלפון",
    "street": "רחוב",
    "student": "אברך",
    "colel": "כולל",
    "shul_name": "שם בית הכנסת",
    "number": "מספר בית",
    "comments": "הערות",
    "start1": "שעת התחלה יום ראשון",
    "start2": "שעת התחלה יום שני",
    "start3": "שעת התחלה יום שלישי",
    "start4": "שעת התחלה יום רביעי",
    "start5": "שעת התחלה יום חמישי",
    "start6": "שעת התחלה יום שישי",
    "end1": "שעת סיום יום ראשון",
    "end2": "שעת סיום יום שני",
    "end3": "שעת סיום יום שלישי",
    "end4": "שעת סיום יום רביעי",
    "end5": "שעת סיום יום חמישי",
    "end6": "שעת סיום יום שישי",
    "0": "יום ראשון",
    "1": "יום שני",
    "2": "יום שלישי",
    "3": "יום רביעי",
    "4": "יום חמישי",
    "5": "יום שישי",
    "manager_name": "שם המנהל",
    "mail_address": "כתובת דואר",
    "address": "כתובת הכולל",
    "schedule": "שעות פעילות",
    "supported_id": "מספר נתמך",
    "name": "שם הכולל"
});
angular.module('RDash')
    .controller('AlertsCtrl', function AlertsCtrl($scope, $cookies) {
        $scope.alerts = [];
        $scope.alerts.push(JSON.parse($cookies.get('alert')) || {});

        $scope.closeAlert = function (index) {
            $scope.alerts.splice(index, 1);
        };
    });
angular.module('RDash')
    .controller('colelController', function ($scope, Data, $rootScope, Helper) {
        var newColel = false;
        $scope.colel = {};
        $scope.total = {
            daily: false,
            prevMonth: false
        };
        
        Data.get('colels').then(updateColels);

        $scope.add = function () {
            $scope.display = true;
            $scope.colel = {
                schedule: [
                    { "start": "00:00", "end": "00:00" },
                    { "start": "00:00", "end": "00:00" },
                    { "start": "00:00", "end": "00:00" },
                    { "start": "00:00", "end": "00:00" },
                    { "start": "00:00", "end": "00:00" },
                    { "start": "00:00", "end": "00:00" }
                ],
                note: {}
            };
            $scope.colel.schedule.map(function (val) {
                val.start = '00:00';
                val.end = '00:00';
            });
            newColel = true;
        };

        $scope.edit = function (id) {
            newColel = false;
            $scope.display = true;
            $scope.colel = angular.copy($scope.colels[id]);
            $scope.colel.is_only_daily = Boolean($scope.colel.is_only_daily);
            $scope.colel.is_prev_month = Boolean($scope.colel.is_prev_month);
            $scope.colel.is_one_time_allow = Boolean($scope.colel.is_one_time_allow);
        };

        $scope.save = function (valid) {
            if (!valid) {
                $scope.formErrors = true;
            } else {
                var method = newColel ? 'put' : 'post';
                $scope.colel.schedule = Helper.stringifyJson($scope.colel.schedule);
                $scope.colel.note = Helper.stringifyJson($scope.colel.note);

                Data[method]('colels', { colel: $scope.colel }).then(updateColels);
                $scope.close();
            }
        };

        $scope.close = function () {
            $scope.colel = {};
            $scope.formErrors = false;
            $scope.display = false;
        };

        function updateColels(data) {
            $scope.colels = data.colels;
            $scope.colels.forEach(function (colel) {
                colel.schedule = Helper.parseJson(colel.schedule);
                colel.note = Helper.parseJson(colel.note);
            });

            $scope.total.daily = $scope.colels.every(colel => Boolean(colel.is_only_daily));
            $scope.total.prevMonth = $scope.colels.every(colel => Boolean(colel.is_prev_month));
        }

        $scope.updateAll = function (param, value) {
            Data.post('updateAll/', {
                column: param,
                value: value
            }).then(Data.get('colels').then(updateColels));
        };

        $scope.timeLapse = function (date) {
            var lastDate = new Date(date);
            var dateDiff = (Date.now() - lastDate.getTime()) / (1000 * 60 * 60 * 24);
            
            if (dateDiff <= 2) {
                return 'OliveDrab';
            } else if (dateDiff <= 7) {
                return 'Orange';
            } else {
                return 'OrangeRed';
            }
        };

        $scope.goTo = function (colel) {
            $scope.away = true;
            // @ts-ignore
            window.open(location.origin, [colel.name, colel.password].join(';'));
        };
    });
angular.module('RDash').controller("dailyController", function ($scope, Data, $filter) {
    $scope.disable = true;
    $scope.dropList = [];
    $scope.isOnlyDaily = true;
    $scope.status = [];

    $scope.show = function (date) {
        if (date) {
            $scope.date = date;
            $scope.disable = true;

            Data.get('daily/' + $scope.date.toLocaleDateString('en-GB').split('/').reverse().join('-')).then(function (data) {
                $scope.students = data.dailyRep;
                $scope.dropList = data.dropList;
                $scope.tempStudents = { amount: data.tempStudents };
                $scope.status = data.status;
            });
        }
    };

    $scope.viewDate = {
        year: new Date().getFullYear(),
        month: new Date().getMonth() + 1
    };

    $scope.changeAll = function (value) {
        $scope.students.forEach(x => x.presence = parseInt(value));
    };

    $scope.students = [];

    Data.get('getProhibitions').then(function (data) {
        if (data) {
            $scope.isOnlyDaily = $scope.$parent.role === 'Admin' ? false : data.is_only_daily;
            $scope.isOneTimeAllow = $scope.$parent.role === 'Admin' || data.is_one_time_allow;
            $scope.show(new Date());

            Data.get('prevDates').then(function (data) {
                $scope.prevDates = data.prevDates;
            });
        }
    });

    $scope.changeMonth = function (currentMonth) {
        if (currentMonth) $scope.viewDate = JSON.parse(currentMonth);
    };

    $scope.save = function (valid) {
        if (!valid) {
            $scope.formErrors = true;
        } else {
            $scope.formErrors = undefined;
            var UPDaily = $scope.students.filter((val) => (val.presence !== null));
            var UPDStud = $scope.tempStudents.amount;
            var UPDdate = $scope.date.toLocaleDateString('en-GB').split('/').reverse().join('-');
            //document.querySelector(".selected").classList.remove("selected");

            Data.put('daily', {
                daily: UPDaily,
                oneTimeStud: UPDStud,
                date: UPDdate
            }).then(function (date) {

            });
            if ($scope.is_only_daily) {
                $scope.close();
            }
        }
    };

    $scope.close = function () {
        $scope.formErrors = undefined;
        $scope.students = undefined;
        $scope.definition = undefined;
        $scope.disable = false;
        document.querySelector(".selected").classList.remove("selected");
    };
});
/**
 * Master Controller
 */

angular.module('RDash')
    .controller('MasterCtrl', function MasterCtrl($scope, $cookies, $rootScope, translate, $location, Data, $state) {
        /**
         * Sidebar Toggle & Cookie Control
         */
        var mobileView = 992;
        var watch = false;

        $scope.userName = $cookies.get('user') || 'משתמש';

        $scope.getWidth = function () {
            return window.innerWidth;
        };

        $scope.logout = function () {
            // Clear all cookies.
            document.cookie.split(";").forEach(function (c) {
                document.cookie = c.replace(/^ +/, "").replace(
                    /=.*/, "=;expires=" + new Date().toUTCString() +
                    ";path=/");
            });

            window.location.href = '/';
        };

        $scope.$watch($scope.getWidth, function (newValue, oldValue) {
            if (newValue >= mobileView) {
                if (angular.isDefined($cookies.get('toggle'))) {
                    $scope.toggle = !$cookies.get('toggle') ? false : true;
                } else {
                    $scope.toggle = true;
                }
            } else {
                $scope.toggle = false;
            }

        });

        $scope.toggleSidebar = function () {
            $scope.toggle = !$scope.toggle;
            $cookies.put('toggle', $scope.toggle);
        };

        $scope.isAgreed = function () {
            return $cookies.get('agree');
        };

        $scope.role = $cookies.get('link');
        $rootScope.t = translate;

        window.onresize = function () {
            $scope.$apply();
        };

        $scope.changedColel = function (e) {

            Data.put('updColel', { currColel: this.currColel }).then(function (data) {
                $state.reload();
            });
        };

        if ($scope.role == 'Admin') {
            Data.get('colelList').then(function (data) {
                $scope.currColel = data.colel_id;
                $scope.colelList = data.colelList;
            });
        }

        var state;
        $("select.form-control").click(function (event) {
            var isMenu = $(this).parent().find('ul').text();
            if (/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)) {
                if (isMenu == "") {
                    window.location = $(this).attr('href');
                } else {
                    if (!state) {
                        state = true;
                        return false;
                    } else {
                        state = false;
                        window.location = $(this).attr('href');
                    }
                }
            } else {
                window.location = $(this).attr('href');
            }
        });
    });
angular.module('RDash')
    .controller('recomendController', function ($scope, Data, $rootScope, Notification) {
        $scope.reload = function (reload) {
            Data.get('recomends').then(function (data) {
                $scope.recomends = data.recomends;
                $scope.stats = data.stats;
                if (reload) Notification.success("נתונים נטענו בהצלחה!");
            });
        };
        $scope.reload();
        $scope.recomend = {};

        $scope.add = function () {
            $scope.display = true;
        };

        $scope.edit = function (id) {
            $scope.display = true;
            $scope.recomend = $scope.recomends[id];
            $scope.editId = id.toString();
        };

        $scope.save = function (valid) {
            if (!valid) {
                $scope.formErrors = true;
            } else if (valid) {
                // var method = $scope.editId ? 'put' : 'post';
                // if (toDelete) {
                //     method = 'delete';
                // }
                // var method = toDelete ? 'delete' : 'post';
                Data.post('recomends', { student: $scope.recomend }).then(function (result) {
                    $scope.recomends = data.recomends;
                });

                $scope.close();
            }
        };

        $scope.close = function () {
            $scope.recomend = {};
            $scope.formErrors = false;
            $scope.display = false;
        };

        $scope.whatChange = function (oldVal, newVal) {
            return (oldVal !== newVal);
        };

        $scope.action = function (originalRecomend, action) {
            var recomend = angular.copy(originalRecomend),
                newObj = recomend.data.newObj;
            
            if (recomend.req_type === "כולל") {
                newObj.schedule = [];
            
                for (var i = 0; i < 7; i++) {
                    if (newObj[i]) {
                        var time = newObj[i].split(' - ');
                        newObj.schedule.push({
                            start: time[0],
                            end: time[1]
                        });
                        delete newObj[i];
                    }
                }
            }

            Data.post(action, { recomend_id: $scope.recomend_id, data: recomend }).then(function (data) {
                if (data.status) originalRecomend.status = data.status;
            });
        };
    });
angular.module('RDash').controller("reportsController", function ($scope, Data, Notification) {

    // $scope.dates = [new Date().toISOString().slice(0, 7)];
    // if (new Date().getDate() < 4) {
    //     $scope.dates.push((function () {
    //         var x = new Date();
    //         x.setDate(1);
    //         x.setMonth(x.getMonth());
    //         return x.toISOString().slice(0, 7)
    //     })());
    // }

    Data.get('definitions').then(function (data) {
        $scope.definitions = data.definitions;
        $scope.test_types = data.test_types;
        $scope.titles = data.titles;
        $scope.reports = data.reports;
        $scope.reportTypes = data.reportTypes;

        $scope.data = {
            colel: null,
            type: null
        };

        Data.get('prevDates').then(function (data) {
            $scope.dates = data.prevDates;
        });
    });

    $scope.f = function (def) {
        console.log(def);
    };

    $scope.refresh = function () {
        $scope.refreshing = true;
        Data.get('reports').then(function (data) {
            $scope.reports = data.reports;
            $scope.refreshing = false;
        });
    };

    $scope.save = function (table_name, object) {
        Data.put('definitions', { table_name, object });
    };

    $scope.changeMonth = function (selected) {
        if (selected) $scope.data.month = selected;
    };

    $scope.changeColel = function (selected) {
        selected = selected || {};
        $scope.data.colel = selected.id;
        $scope.data.colelName = selected.name;

        $scope.data.type = null;
        $scope.data.typeName = null;
    };

    $scope.changeType = function (selected) {
        $scope.data.type = selected.id;
        $scope.data.typeName = selected.name;

        $scope.data.colel = null;
        $scope.data.colelName = null;
    };

    $scope.newReport = function (type) {
        if (!type || !type.id || !$scope.data.month || (type.id == 1 && !$scope.data.colel)) {
            Notification.warning("חסרים נתונים בכדי להנפיק דוח");
        } else {
            $scope.data.type = type.id;

            Data.put('newReport', $scope.data).then(function (res) {
                if (res.success) {
                    $scope.reports.push({
                        report: $scope.reportTypes[$scope.data.type - 1].name,
                        colel: $scope.data.colelName,
                        date_created: $scope.data.month,
                        url: res.url
                    });
                } else {
                    Notification.warning('לא ניתן היה להפיק את הדוח');
                }
            });
        }
    };
});
angular.module('RDash')
    .controller('scoresController', function ($scope, Data) {
        $scope.students = [];
        $scope.dropList = {};
        $scope.UPDstud = [];

        $scope.loadData = function (selectedDate) {
            var date = selectedDate ? new Date(selectedDate) : new Date();
            $scope.date = date.toLocaleDateString('en-GB').split('/').reverse().join('-');

            Data.get('scores/' + $scope.date).then(function (data) {
                $scope.students = data.scores;
                $scope.title = data.test_type;
            });
        };
        
        Data.get('prevDates').then(function (data) {
            $scope.prevDates = data.prevDates;
        });

        $scope.changeMonth = function (currentMonth) {
            if (currentMonth) $scope.loadData(Object.values(JSON.parse(currentMonth)).join('-'));
        };

        $scope.save = function (data) {
            $scope.UPDstud = $scope.students.filter((val) => (val.oral || val.oral === 0 || val.write || val.comment));
            Data.put('scores', {
                score: $scope.UPDstud,
                date: $scope.date
            }).then(function (data) {

            });
        };

        $scope.loadData();
    });
angular.module('RDash')
    .controller('settingsController', function ($scope, Data, $state, $cookies, Notification) {
        if ($cookies.get('link') === 'Admin') {
            $state.go('recomends');
        }

        var copy;

        // $scope.data = {
        //     address: 'חנה רובינא 23 פתח תקוה בית הכנסת חב"ד יום ג: בית כנסת בישטנא רח\' עדש שפיק פינת עזרה ונחמיה',
        //     mail_address: "יהודה הנשיא 41 פתח תקוה",
        //     phone: '054-7770847',
        //     manager_name: "מענדי גרברצ'יק",
        //     schedule: [{
        //         "start": "20:00",
        //         "end": "21:30"
        //     }, {
        //         "start": "20:00",
        //         "end": "21:30"
        //     }, {
        //         "start": "20:00",
        //         "end": "21:30"
        //     }, {
        //         "start": "20:00",
        //         "end": "21:30"
        //     }, {
        //         "start": "20:00",
        //         "end": "21:30"
        //     }, {
        //         "start": "20:00",
        //         "end": "21:30"
        //     }]
        // };

        Data.get('colelSettings').then(function (data) {
            $scope.data = data.data;
            $scope.data.schedule = JSON.parse($scope.data.schedule);
            copy = angular.copy($scope.data);
        });

        $scope.submitData = function (changed) {
            if ($scope.agree) {
                $cookies.put('agree', true);

                // var changedData = {};

                // angular.forEach($scope.data, function (value, key) {
                //     if ($scope.settingsForm[key].$dirty) {
                //         changedData[key] = value;
                //     };
                // });

                if (!angular.equals($scope.data, copy)) {
                    Data.post('recomends', {
                        data: { newObj: $scope.data, oldObj: copy },
                        table: 'colel',
                        type: 'עריכה'
                    }, function (data) {

                    });
                }
                $state.go('recomends');

            } else {
                Notification.error('חובה לאשר את הנתונים');
            }
        };
    });
angular.module('RDash')
    .controller('studentController', function ($scope, Data) {
        Data.get('students').then(function (data) {
            $scope.students = data.students;
        });

        $scope.student = {};
        $scope.isNew = false;
        $scope.editId = null;
        $scope.add = function () {
            $scope.isNew = $scope.display = true;
            $scope.student = {};
        };

        $scope.edit = function (id) {
            $scope.isNew = false;
            $scope.display = true;
            $scope.student = angular.copy($scope.students[id]);
            $scope.editId = id.toString();
        };

        $scope.save = function (valid, toDelete) {
            var type = '';

            delete $scope.student.name;
            var data = {
                oldObj: null,
                newObj: $scope.student
            };
            if (toDelete) {
                type = 'מחיקה';
            } else if ($scope.isNew) {
                type = 'הוספה';
            } else {
                type = 'עריכה';
                data.oldObj = $scope.students[$scope.editId];
            }


            if (!valid) {
                $scope.formErrors = true;
            } else if (valid) {

                Data.post('recomends', { data: data, table: 'student', type: type }).then(function (result) {

                });

                $scope.close();
            }
        };

        $scope.deleteStud = function (valid) {
            if (!valid) {
                $scope.formErrors = true;
            } else if (valid) {
                $scope.student.schedule = JSON.stringify($scope.student.schedule);
                Data.post('recomends', { data: $scope.student, table: 'student', type: 'מחיקה' }).then(function (result) {

                });

                $scope.close();
            }
        };

        $scope.close = function () {
            $scope.student = {};
            $scope.formErrors = false;
            $scope.display = false;
            $scope.editId = null;
        };
    });